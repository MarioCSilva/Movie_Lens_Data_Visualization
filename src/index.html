<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript" src="http://d3js.org/d3.v6.js"></script>

    <!-- for word cloud -->
    <script src="./js/cloud.js"></script>


    <title>MovieLens Data Visualization</title>
</head>

<body>
    <div id="barchart_genres"></div>
    <div id ="lineplot_genres"></div>
    <div id="box_plot_popularity"></div>
    <div id="scatter_movies"></div>
    <div id="word_cloud_tags"></div>

    <script>
        let movies = {};

        let movie_popularity = {};

        let genres_review_counter = {};

        var max_num_reviews = 0;

        // for word cloud of most popular tags
        var max_num_tags = 50;
        var tags_height = 600;
        var tags_width = document.body.clientWidth;

        // set the dimensions and margins of the graph
        var margin = { top: 10, right: 30, bottom: 55, left: 60 },
            width = 460 - margin.left - margin.right,
            height = 400 - margin.top - margin.bottom;


        // append the svg object to the body of the page
        const barchart_svg = d3.select("#barchart_genres")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

        // append the svg object to the body of the page
        const lineplot_svg = d3.select("#lineplot_genres")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")");

        const scatter_svg = d3.select("#scatter_movies")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left}, ${margin.top})`);

        const box_plot_svg = d3.select("#box_plot_popularity")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


        // Preprocess movies
        // Uses global variable movies
        // dataset: movieId,title,genres
        function preProcessMovies(data) {
            for (let i = 0; i < data.length; i++) {
                genres = data[i].genres.split('|')
                movies[data[i].movieId] = { 'title': data[i].title, 'genres': genres }
            }
        }

        function drawBoxPlot(movie_popularity) {
            // Compute quartiles, median, inter quantile range min and max --> these info are then used to draw the box.
            var sumstat = d3.nest() // nest function allows to group the calculation per level of a factor
                .key(function (d) { return d.Species; })
                .rollup(function (d) {
                    q1 = d3.quantile(d.map(function (g) { return g.Sepal_Length; }).sort(d3.ascending), .25)
                    median = d3.quantile(d.map(function (g) { return g.Sepal_Length; }).sort(d3.ascending), .5)
                    q3 = d3.quantile(d.map(function (g) { return g.Sepal_Length; }).sort(d3.ascending), .75)
                    interQuantileRange = q3 - q1
                    min = q1 - 1.5 * interQuantileRange
                    max = q3 + 1.5 * interQuantileRange
                    return ({ q1: q1, median: median, q3: q3, interQuantileRange: interQuantileRange, min: min, max: max })
                })
                .entries(data)

            // Show the X scale
            var x = d3.scaleBand()
                .range([0, width])
                .domain(["setosa", "versicolor", "virginica"])
                .paddingInner(1)
                .paddingOuter(.5)
            box_plot_svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x))

            // Show the Y scale
            var y = d3.scaleLinear()
                .domain([3, 9])
                .range([height, 0])
            box_plot_svg.append("g").call(d3.axisLeft(y))

            // Show the main vertical line
            box_plot_svg
                .selectAll("vertLines")
                .data(sumstat)
                .enter()
                .append("line")
                .attr("x1", function (d) { return (x(d.key)) })
                .attr("x2", function (d) { return (x(d.key)) })
                .attr("y1", function (d) { return (y(d.value.min)) })
                .attr("y2", function (d) { return (y(d.value.max)) })
                .attr("stroke", "black")
                .style("width", 40)

            // rectangle for the main box
            var boxWidth = 100
            box_plot_svg
                .selectAll("boxes")
                .data(sumstat)
                .enter()
                .append("rect")
                .attr("x", function (d) { return (x(d.key) - boxWidth / 2) })
                .attr("y", function (d) { return (y(d.value.q3)) })
                .attr("height", function (d) { return (y(d.value.q1) - y(d.value.q3)) })
                .attr("width", boxWidth)
                .attr("stroke", "black")
                .style("fill", "#69b3a2")

            // Show the median
            box_plot_svg
                .selectAll("medianLines")
                .data(sumstat)
                .enter()
                .append("line")
                .attr("x1", function (d) { return (x(d.key) - boxWidth / 2) })
                .attr("x2", function (d) { return (x(d.key) + boxWidth / 2) })
                .attr("y1", function (d) { return (y(d.value.median)) })
                .attr("y2", function (d) { return (y(d.value.median)) })
                .attr("stroke", "black")
                .style("width", 80)
        }

        function drawScatterPlot(movie_popularity) {
            // Add X axis
            const x = d3.scaleLinear()
                .domain([0, max_num_reviews])
                .range([0, width]);

            scatter_svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x));

            const y = d3.scaleLinear()
                .domain([0, 5])
                .range([height, 0]);
            scatter_svg.append("g")
                .call(d3.axisLeft(y));


            // Add dots
            scatter_svg.append('g')
                .selectAll("dot")
                .data(movie_popularity.entries())
                .join("circle")
                .attr("cx", function (d) { return x(d[1].num_reviews); })
                .attr("cy", function (d) { return y(d[1].avg); })
                .attr("r", 1.5)
                .style("fill", "#69b3a2")
        }


        function parseTimestamp(timestamp) {
            timestamp = parseInt(timestamp);
            var u = new Date(timestamp * 1000);
            return u.getUTCFullYear() +
                '-' + ('0' + u.getUTCMonth()).slice(-2) +
                '-' + ('0' + u.getUTCDate()).slice(-2)
        }



        // dataset: userId,movieId,rating,timestamp
        function preProcessRatings(data) {
            ratings = [];
            for (let i = 0; i < data.length; i++) {
                movie_id = data[i].movieId
                ratings.push(data[i]);
                date = parseTimestamp(data[i].timestamp);
                if (date == 'date'){
                    console.log("aaa")
                }
                if (!movie_popularity[movie_id]) {

                    movie_popularity[movie_id] = {
                        'avg': parseInt(data[i].rating),
                        'num_reviews': 1,
                        'ratings': [parseInt(data[i].rating)],
                        'dates': {}
                    }
                    movie_popularity[movie_id].dates[date]= [data[i].rating]; 

                }
                else {
                    movie_popularity[movie_id].num_reviews = movie_popularity[movie_id].num_reviews + 1
                    movie_popularity[movie_id].ratings.push(parseInt(data[i].rating))
                    if (movie_popularity[movie_id].num_reviews > max_num_reviews) {
                        max_num_reviews = movie_popularity[movie_id].num_reviews
                    }

                    if (!movie_popularity[movie_id].dates[date]) {
                        movie_popularity[movie_id].dates[date] = [data[i].rating];
                    }
                    else {
                        movie_popularity[movie_id].dates[date].push(data[i].rating);
                    }

                }

            }
            for (let movie in movie_popularity) {
                ratings = movie_popularity[movie].ratings
                sum = ratings.reduce((a, b) => a + b, 0)
                movie_popularity[movie].avg = sum / ratings.length
            }

            return movie_popularity
        }

        function preProcessGenresReviews(movie_popularity) {
            //TODO: maybe pass this to previous function to avoid another for loop?
            genres_arr = [];
            for (let movie in movie_popularity) {
                genres = movies[movie].genres;
                ratings = movie_popularity[movie].ratings.length
                for (let i = 0; i < genres.length; i++) {
                    genre = genres[i];
                    if (!genres_review_counter[genre]) {
                        genres_review_counter[genre] = ratings;
                        genres_arr.push(genre)

                    }
                    else {
                        genres_review_counter[genre] += ratings;
                    }
                }
            }
            const index = genres_arr.indexOf('(no genres listed)');
            if (index > -1) {
                genres_arr.splice(index, 1);
                delete genres_review_counter['(no genres listed)'];
            }
            return genres_review_counter;
        }


        function preProcessGenreReviewsThroughTime(movie_popularity) {
            genres_reviews_time = [];
            for (let movie in movie_popularity) {
                genres = movies[movie].genres;
                ratings = movie_popularity[movie].ratings.length
                dates = movie_popularity[movie].dates;
                for (let i = 0; i < genres.length; i++) {
                    genre = genres[i];
                    for (let date in dates) {
                        all_reviews = dates[date].length;
                        obj = { 'genre': genre, 'timestamp': date, 'num_reviews': all_reviews };
                        genres_reviews_time.push(obj);
                    }
                }
            }
            return genres_reviews_time;
        }


        function drawBarChart(data) {

            const values = Object.values(data);
            console.log(values)
            max_num = Math.max(...values);
            console.log(max_num)

            data = Object.entries(data);
            // X axis
            var x = d3.scaleBand()
                .range([0, width])
                .domain(data.map(function (d) { return d[0]; }))
                .padding(0.2);
            barchart_svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x))
                .selectAll("text")
                .attr("transform", "translate(-10,0)rotate(-45)")
                .style("text-anchor", "end");

            // Add Y axis
            var y = d3.scaleLinear()
                .domain([0, max_num])
                .range([height, 0]);
            barchart_svg.append("g")
                .call(d3.axisLeft(y));


            barchart_svg.selectAll("mybar")
                .data(data)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", function (d) { return x(d[0]); })
                .attr("y", function (d) { return y(d[1]); })
                .attr("width", x.bandwidth())
                .attr("height", function (d) { return height - y(d[1]); })
                .attr("fill", "#69b3a2");

        }


        function drawWordCloud(tags) {
            fill = d3.scaleOrdinal(d3.schemeCategory10);

            d3.layout.cloud()
                .size([tags_width, tags_height])
                .words(
                    tags.map(function (tag) {
                        return { text: tag[0], size: tag[1] };
                    }))
                .padding(2)
                .font("Impact")
                .fontSize(function (tag) {
                    return tag.size;
                })
                .on("end", drawTags)
                .start();

            function drawTags(tags) {
                d3.select("#word_cloud_tags").append("svg")
                    .attr("width", tags_width)
                    .attr("height", tags_height)
                    .append("g")
                    .attr("transform", "translate(" + [tags_width >> 1, tags_height >> 1] + ")")
                    .selectAll("text")
                    .data(tags)
                    .enter()
                    .append("text")
                    .style("font-size", function (d) { return d.size + "px"; })
                    .style("font-family", "Impact")
                    .attr("text-anchor", "middle")
                    .style("fill", function (d, i) { return fill(i); })
                    .attr("transform", function (d) {
                        return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
                    })
                    .text(function (d) { return d.text; });
            }

            d3.layout.cloud().stop();
        }


        function drawLinePlot(data) {
            


            // group the data: I want to draw one line per group
            let sumstat = d3.group(data, d => d.genre)
            


            data.forEach(function(d){
                d.timestamp = d3.timeParse("%Y-%m-%d")(d.timestamp);
            });
            // Add X axis --> it is a date format
            let x = d3.scaleTime()
                .domain(d3.extent(data, function (d) { return d.timestamp; }))
                .range([0, width]);
            lineplot_svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x).ticks(5));

            // Add Y axis
            let y = d3.scaleLinear()
                .domain([0, d3.max(data, function (d) { return +d.num_reviews; })])
                .range([height, 0]);
            lineplot_svg.append("g")
                .call(d3.axisLeft(y));

            console.log(sumstat);
            // color palette
            let res = Array.from(sumstat.keys()); // list of group names
            let color = d3.scaleOrdinal()
                .domain(res)
                .range(['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf',
                 '#999999', '#14d0df', '#81628d', '#04cece','#039999', '#039999', '#23855d', '#23855d', '#b5e655', '#f5803c', '#fbcfb6' ])

            // Draw the line
            lineplot_svg.selectAll(".line")
                .data(sumstat)
                .enter()
                .append("path")
                .attr("fill", "none")
                .attr("stroke", function (d) { return color(d.genre) })
                .attr("stroke-width", 1.5)
                .attr("d", function (d) {
                    return d3.line()
                        .x(function (d) { return x(d.timestamp); })
                        .y(function (d) { return y(+d.num_reviews); })
                        (d.values)
                })


        }


        // scale x into a range [a, b]
        function scaleData(a, b, min, max, tags) {
            for (let i = 0; i < tags.length; i++) {
                tags[i][1] = (b - a) * ((tags[i][1] - min) / (max - min)) + a
            }
        }

        // dataset: userId,movieId,tag,timestamp
        function preProcessTags(data) {
            tags = {}
            for (let i = 0; i < data.length; i++) {
                if (!tags[data[i].tag]) {
                    tags[data[i].tag] = 1;
                } else {
                    tags[data[i].tag] += 1;
                }
            }

            tags = Object.entries(tags)

            tags.sort(
                (first, second) => { return second[1] - first[1] }
            )

            tags = tags.slice(0, max_num_tags)
            max = tags[0][1]
            min = tags[max_num_tags - 1][1]
            scaleData(20, 70, min, max, tags)
            return tags
        }


        function draw() {
            d3.csv("../dataset/ratings.csv")
                .then((data) => {
                    movie_popularity = preProcessRatings(data)
                    movies_pop_arr = Object.values(movie_popularity)
                    genres_reviews = preProcessGenresReviews(movie_popularity);
                    genres_through_time = preProcessGenreReviewsThroughTime(movie_popularity);
                    //drawBoxPlot(movie_popularity)
                    drawBarChart(genres_reviews)
                    drawScatterPlot(movies_pop_arr)
                    drawLinePlot(genres_through_time)
                }).catch(err => { console.log(err) });

            d3.csv("../dataset/tags.csv")
                .then((data) => {
                    tags = preProcessTags(data);
                    drawWordCloud(tags);
                }).catch(err => { console.log(err) });



            //d3.csv("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/5_OneCatSevNumOrdered.csv", function(data) {
            //    console.log(data)
            //});

        }

        // initial load of data that only will be executed once
        d3.csv("../dataset/movies.csv")
            .then((data) => {
                preProcessMovies(data)
                draw()
            }).catch(err => { console.log(err) });

    </script>
</body>

</html>